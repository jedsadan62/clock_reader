# -*- coding: utf-8 -*-
"""A3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QQFrZ0OhVuwrlQmJLCmVv0dbipifFatS
"""

import cv2
import numpy as np
import math
import os
from google.colab.patches import cv2_imshow

class clockReader:
  def __init__(self,path):
    self.Image_path = path #'/content/drive/MyDrive/clock/data-resampled/clock_0630.png'
    if len(self.Image_path)>0:
      self.clock_image = cv2.imread(self.Image_path)
      self.display_image = self.clock_image.copy()
      (self.Image_h,self.Image_w)=self.clock_image.shape[:2]
      (cY,cX)=(self.Image_h//2,self.Image_w//2)
      M = cv2.getRotationMatrix2D((cX, cY), 2.5, 1.0)
      self.clock_image = cv2.warpAffine(self.clock_image, M, (self.Image_w,self.Image_h))
      self.clock_pin = self.Cut_clock_pin()
      self.L_pin = self.L_Clock_pin()
      self.read_time = self.clock_compute()
    else:
      print("Path Error")
  
  def Cut_clock_pin(self):#Cut only pin of clock
    imgContour = cv2.cvtColor(self.clock_image,cv2.COLOR_BGR2GRAY)
    g_image = cv2.cvtColor(self.clock_image,cv2.COLOR_BGR2GRAY)
    imgContour = cv2.bitwise_not(imgContour)
    mask = np.zeros((self.Image_h,self.Image_w), np.uint8)
    rows = g_image.shape[0]
    circles = cv2.HoughCircles(g_image, cv2.HOUGH_GRADIENT, 1, rows/8,
                               param1=30, param2=30,
                               minRadius=210, maxRadius=220)
    if circles is not None :
        circles = np.uint16(np.around(circles))
        for i in circles[0, :]:
            center =(418, 260)
            self.circle_center = center
            radius = i[2]
            cv2.circle(mask, center, radius, (0, 0, 0), -1)
            cv2.circle(mask, center, radius-78, (255, 255, 255), -1)
            cv2.circle(mask, center, 130, (0, 0, 0), -1)
    masked_data = cv2.bitwise_and(imgContour,imgContour, mask=mask)
    white = np.where(masked_data/255>=0.48)
    black = np.where(masked_data/255<0.48)
    masked_data[white]=255
    masked_data[black]=0
    return masked_data

  def L_Clock_pin(self):#find long clock pin
    image = self.clock_pin.copy()
    imgContour =self.clock_image.copy()
    center =self.circle_center
    kernel = np.ones((1, 1), np.uint8)
    _,binary_clock = cv2.threshold(image,140,255,cv2.THRESH_BINARY)
    binary_clock = cv2.erode(binary_clock, kernel, iterations=4)
    contours,_= cv2.findContours(binary_clock,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_NONE)
    self.pin_position = []
    for cnt in contours:
      area = cv2.contourArea(cnt)
      if area>=5:
          peri = cv2.arcLength(cnt,True)
          approx = cv2.approxPolyDP(cnt,0.02*peri,True)
          x,y,w,h = cv2.boundingRect(approx)
          cv2.rectangle(imgContour,(x,y),(x+w,y+h),(0,255,0),1)
          center_point_x,center_point_y = (x+int(((x+w)-x)/2),y+int(((y+h)-y)/2))
          D = (((center_point_x-center[0])**2)+((center_point_y-center[1])**2))**(0.5)
          cv2.line(imgContour, self.circle_center, (center_point_x,center_point_y), (0,255,0),1)
          cv2.putText(imgContour, 'Dist = {0}'.format(D), (x,y), cv2.FONT_HERSHEY_SIMPLEX, 
                   1, (0,255,0), 2, cv2.LINE_AA)
          self.pin_position.append((center_point_x,center_point_y,area))
    return image
    
  def clock_compute(self):
    read_time = []
    try :
      for x,y,area in self.pin_position:
        a = x-self.circle_center[0]#delta x
        b = y-self.circle_center[1]#delta y
        c = math.sqrt((b**2)+(a**2))
        pi = 22/7
        a=abs(a)
        c=abs(c)
        if x >= self.circle_center[0] and y <= self.circle_center[1]:
          # print("Q1")
          rad = math.asin(a/c)
          degree = rad *(180/pi)
        elif x >= self.circle_center[0] and y >= self.circle_center[1]:
          # print("Q2")
          rad = math.acos(a/c)
          degree = (rad *(180/pi))+90
        elif x <= self.circle_center[0] and y >= self.circle_center[1]:
          # print("Q3")
          rad = math.asin(a/c)
          degree = (rad *(180/pi))+180
        elif x <= self.circle_center[0] and y <= self.circle_center[1]:
          # print("Q4")
          rad = math.acos(a/c)
          degree = rad *(180/pi)+270
        read_time.append((area,c,degree))
      read_time.sort(reverse=True)
      if len(read_time) < 2:
        Long_hand_d  = read_time[0][2]+2
        short_hand_d  = Long_hand_d
      else :
        Long_hand_d  = read_time[0][2]+2
        short_hand_d  = read_time[1][2]
      hour = math.trunc(short_hand_d /30)
      minute = math.trunc(Long_hand_d /6)
      if len(str(hour)) < 2:
        zero_h = '0'
      else:
        zero_h = ''
      if len(str(minute)) < 2:
        zero_m = '0'
      else:
        zero_m = ''
      return "{0}{1}{2}{3}".format(zero_h,hour,zero_m,minute)
    except :
      return "Error"

class Accracy_Compute :
  def __init__(self,firename,time_input):
      self.firename = firename.replace(".png", "")
      self.firename = self.firename.replace(".jpg", "")
      self.firename = self.firename.replace("clock_", "")
      self.time_input = time_input
      self.score = self.give_scored()
  def give_scored(self):
      if self.firename == self.time_input:
        return 1
      else:
        return 0

data_folder_path ='/content/drive/MyDrive/clock/data-resampled'
totol_score = 0
counter = 0
for dataset_file in os.listdir(data_folder_path):
  if dataset_file == "clock_0306.png" :
    clock = clockReader("{0}/{1}".format(data_folder_path,dataset_file))
    cv2_imshow(clock.L_pin)
    Image_score = Accracy_Compute(dataset_file,clock.read_time)
    counter+=1
    if Image_score.score == 0 :
      print("time of {0}  = {1} ".format(dataset_file,clock.read_time))
    totol_score = totol_score + Image_score.score
print("Total Image :",counter)
print("Total Score :",totol_score)
print("ACC ={0} ".format((totol_score/counter)*100))
cv2.waitKey(0)